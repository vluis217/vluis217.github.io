I"%<h2 id="el-problema">El problema</h2>

<p>Como muchas personas saben, administro el <a href="https://vluis217.github.io/posts/stemjobs-faq/">proyecto STEM Jobs CR</a> desde hace tiempo, el cual consiste en un bot que monitorea continuamente m√°s de 200 bolsas de empleo y env√≠a notificaciones a Telegram, Discord y WhatsApp cuando detecta nuevas publicaciones de puestos de empleo en STEM.</p>

<p>Hace unas semanas mi bot empez√≥ a fallar de forma intermitente, y al revisar los logs me di cuenta que estaba tardando mucho m√°s de lo normal en terminar su ejecuci√≥n. Adem√°s, not√© que hab√≠a muchas instancias del bot ejecut√°ndose en segundo plano, algunas hasta con d√≠as de estar ‚Äúcolgadas‚Äù, sin terminar nunca.</p>

<p>Despu√©s de investigar un poco m√°s, determin√© cu√°l era la bolsa de empleo que estaba causando el problema. El URL de la bolsa de empleo en cuesti√≥n funcionaba sin problemas desde el navegador en mi PC personal, lo cual me dejaba dos posibles causas:</p>
<ol>
  <li>El servidor bloque√≥ la direcci√≥n IP de mi bot: poco probable, ya que en mi PC local pude reproducir el mismo comportamiento que en mi servidor en la nube, enviando requests con c√≥digo.</li>
  <li>Los requests a la bolsa de empleo ahora requieren un token, cookie y/o header adicional, lo cual explicar√≠a por qu√© en el navegador no hay problemas.</li>
</ol>

<p>Teniendo eso en cuenta, empec√© a explorar la segunda posibilidad. Copi√© el request del navegador en formato cURL (usando las herramientas de desarrollador), y ejecut√© el request desde la terminal.
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/devtools.png" alt="devtools" /></p>

<p>El request funcion√≥ correctamente sin colgarse. Como siguiente paso en la investigaci√≥n, empec√© a quitar headers del request y a reproducirlo para intentar determinar cu√°l o cu√°les eran los headers m√≠nimos necesarios para que el request fuera exitoso.</p>

<p>Aqu√≠ encontr√© otro comportamiento inconsistente: cuando ejecutaba un request con los mismos headers que hab√≠a copiado del navegador, funcionaba sin problemas, pero al quitar la mayor√≠a de headers los requests segu√≠an siendo exitosos, y si intentaba reproducir el mismo request con pocos headers en una sesi√≥n aparte, los requests volv√≠an a fallar. O sea, es como si el servidor tomara en cuenta requests exitosos anteriores en la misma sesi√≥n para validar requests nuevos, sin importar los headers de √©stos.</p>

<p>Dicho comportamiento me hizo pensar que tal vez la bolsa de empleo ahora estaba detr√°s de alg√∫n control de seguridad, como un WAF por ejemplo, as√≠ que consult√© los registros DNS del host para saber a qu√© IP estaba apuntando:
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/dig.png" alt="dig" />
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/whois.png" alt="whois" /></p>

<p>Tanto la direcci√≥n IP como los dominios de los CNAMEs son propiedad de Akamai, lo cual explica tanto el problema inicial de ‚Äúlatencia infinita‚Äù, como la inconsistencia al usar requests aparentemente similares en diferentes sesiones de comunicaci√≥n.</p>

<p>Seg√∫n Wikipedia, Akamai es una compa√±√≠a especializada en content delivery network (CDN), ciberseguridad, mitigaci√≥n de ataques DDoS y servicios en la nube. Y como an√©cdota personal, hace a√±os tuve un par de entrevistas laborales ah√≠, y en el proceso me di cuenta que en esa empresa tienen un conocimiento bastante amplio y profundo de c√≥mo funcionan las redes a bajo nivel, con un enfoque especial en el proceso ‚Äú<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation"><em>three-way handshake</em></a>‚Äù del protocolo TCP. Adem√°s de esto, record√© que existen t√©cnicas de <a href="https://nmap.org/book/synscan.html">escaneo</a> de <a href="https://nmap.org/book/scan-methods-ack-scan.html">puertos de red</a> y <a href="https://attack.mitre.org/techniques/T1499/001/">ataques de denegaci√≥n de servicio</a> que consisten en manipular el proceso de three-way handshake y la funcionalidad general del protocolo TCP para lograr sus objetivos respectivos.<br />
<em>Nota: la t√©cnica de bloqueo de bots usada en este caso se llama ‚Äú</em><a href="https://en.wikipedia.org/wiki/Tarpit_%28networking%29"><em>tarpit</em></a><em>‚Äù (¬°gracias a Jose Hernan Perez en LinkedIn por se√±alarlo!)</em></p>

<hr />

<p><img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/meme.png" alt="meme" /></p>

<h2 id="analizando-la-conexi√≥n-con-wireshark">Analizando la conexi√≥n con Wireshark</h2>

<p>Con esa informaci√≥n, decid√≠ usar Wireshark para inspeccionar la conexi√≥n de mi bot con el servidor de la bolsa de empleo, para confirmar qu√© estaba pasando exactamente.</p>

<p>Primero, captur√© el comportamiento ‚Äúnormal‚Äù, es decir, cuando mi navegador hace el request al servidor de la bolsa de empleo, y recibe la respuesta esperada.
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/wireshark1.png" alt="wireshark1" />
<em>[se omite parte de la comunicaci√≥n]</em>
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/wireshark2.png" alt="wireshark2" /></p>

<p>Como se puede ver en las capturas de pantalla, la sesi√≥n TCP se establece con un three-way handshake, el cliente (mi navegador) env√≠a el request, el servidor lo recibe y empieza a enviar los datos del mismo. Finalmente, el cliente env√≠a un paquete FIN ACK para cerrar la sesi√≥n con el servidor, y la comunicaci√≥n termina.<br />
<em>Nota: para ver el tr√°fico HTTPS sin cifrado,</em> <a href="https://wiki.wireshark.org/TLS#using-the-pre-master-secret"><em>utilic√© esta gu√≠a</em></a><em>.</em></p>

<p>Sin embargo, al hacer un request con el mismo URL pero usando mi bot escrito en Python, la comunicaci√≥n se desarrolla de forma diferente:
<img src="/assets/img/posts/akamai-friendzoneo-a-mi-bot/wireshark3.png" alt="wireshark3" /></p>

<p>La conexi√≥n se establece normalmente igual que en el ejemplo anterior, pero tan pronto como el servidor recibe el HTTP request, deja de responder, sin enviar ning√∫n paquete FIN o RST. Al terminar forzosamente el proceso de mi bot, el mismo env√≠a un FIN ACK al servidor, y el este contesta con un RST, lo cual asumo que significa que el servidor ya hab√≠a terminado la sesi√≥n de su lado, y no tiene ‚Äúconocimiento‚Äù de la sesi√≥n que mi cliente hab√≠a establecido hace unos segundos.</p>

<p>En resumen: cuando el servidor de Akamai recibe un request fuera de lo com√∫n, simplemente bota la conexi√≥n TCP de su lado, sin dejarle saber al cliente que lo hizo. Esto confirma el comportamiento que sospech√© inicialmente.</p>

<hr />

<h2 id="la-soluci√≥n">La soluci√≥n</h2>

<p>Mi bot usa la biblioteca <a href="https://requests.readthedocs.io/en/latest/">requests</a>, que simplifica enormemente la creaci√≥n y manipulaci√≥n de HTTP requests en Python.</p>

<p>Despu√©s de investigar m√°s a fondo su funcionamiento, me di cuenta que esta biblioteca no tiene timeouts definidos por defecto, pero dispone del <a href="https://requests.readthedocs.io/en/stable/user/advanced/#timeouts">par√°metro <code class="language-plaintext highlighter-rouge">timeout</code></a>, el cual se puede usar de dos maneras:</p>
<ul>
  <li>Si se define un √∫nico valor num√©rico, √©ste se interpretar√° como la cantidad m√°xima de segundos que se esperar√°, tanto para que la conexi√≥n inicial se establezca, como para que el servidor env√≠e paquetes de respuesta al cliente.</li>
  <li>Definiendo una tupla de valores num√©ricos, es posible especificar por aparte el tiempo de espera para el <code class="language-plaintext highlighter-rouge">connect</code> inicial y para cada <code class="language-plaintext highlighter-rouge">read</code>.</li>
</ul>

<p>Tambi√©n es posible especificar <code class="language-plaintext highlighter-rouge">None</code> como valor de este par√°metro, pero √©se es el comportamiento por defecto, como se puede ver en el <a href="https://github.com/psf/requests/blob/main/src/requests/sessions.py#L510">c√≥digo fuente de la biblioteca</a>.</p>

<p>Por lo tanto, usando el par√°metro <code class="language-plaintext highlighter-rouge">timeout</code>, se pueden evitar este tipo de cuelgues ‚Äúinfinitos‚Äù:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">https://jobs.com/api/</span><span class="sh">'</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Despu√©s de implementar estos timeouts en mi c√≥digo, ahora el bot espera nada m√°s 15 segundos despu√©s de hacer el HTTP request, y despu√©s falla con un error de tipo <code class="language-plaintext highlighter-rouge">requests.exceptions.ReadTimeout</code>, lo cual previene que se cuelgue indefinidamente.</p>

<p><em>PD: Para volver a extraer la informaci√≥n de empleos exitosamente de esa bolsa de empleo, simplemente agregu√© a mi bot los headers que env√≠a normalmente el navegador cuando hace un request a esa URL</em> üòâ</p>
:ET